import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'
import { fetchTranslatedPosts } from './translatorAPI';


const initialState = {
    translatedPosts: [],
    status: 'idle',
    error: null
}

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(fetchTranslated())`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const fetchTranslated = createAsyncThunk('translator/fetchTranslated', async (data) => {
    const response = await fetchTranslatedPosts(data.data, data.fromLanguage, data.toLanguage)
    // The value we return becomes the `fulfilled` action payload
    return response.data
});


const translatorSlice = createSlice({
    name: 'translatedPosts',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        // Redux Toolkit allows us to write "mutating" logic in reducers. It
        // doesn't actually mutate the state because it uses the Immer library,
        // which detects changes to a "draft state" and produces a brand new
        // immutable state based off those changes;

        clearPosts: (state) => {
            state.translatedPosts = initialState.translatedPosts;
        },
        postAdded: {
            reducer(state, action) {
                state.translatedPosts.push(action.payload)
            }
        }
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers(builder) {
        builder
            .addCase(fetchTranslated.pending, (state, action) => {
                state.status = 'loading'
            })
            .addCase(fetchTranslated.fulfilled, (state, action) => {
                state.status = 'succeeded'
                // Add any fetched posts to the array
                state.translatedPosts = state.translatedPosts.concat(action.payload)
            })
            .addCase(fetchTranslated.rejected, (state, action) => {
                state.status = 'failed'
                state.error = action.error.message
            })
    }
})

export const { postAdded, postUpdated, reactionAdded, clearPosts } = translatorSlice.actions

export default translatorSlice.reducer

// The function below is called a selector and allows us to select all translated posts from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.translatedPosts.translatedPosts)`
export const selectAllTranslatedPosts = state => state.translatedPosts.translatedPosts


export const setDataToTranslate = (posts) => {
    let data = {
        'titles': [],
        'bodies': []
    }
    posts.forEach(element => {
        data['titles'].push({ 'text': element.title });
        data['bodies'].push({ 'text': element.body });
    });
    return data;
}


export const getTranslatedPosts = (posts, data) => {
    const middleIndex = Math.floor(data.length / 2);
    const titles = data.slice(0, middleIndex);
    const bodies = data.slice(middleIndex);

    return posts.map((post, index) => ({
        ...post,
        title: titles[index].translations[0].text,
        body: bodies[index].translations[0].text,

    }));

}

